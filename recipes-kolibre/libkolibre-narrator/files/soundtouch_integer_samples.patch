Index: git/configure.ac
===================================================================
--- git.orig/configure.ac
+++ git/configure.ac
@@ -123,19 +123,11 @@ AC_ARG_ENABLE(integer-samples,
 if test "x$enable_integer_samples" = "xyes"; then
         echo "****** Integer sample type enabled ******"
         AC_DEFINE(INTEGER_SAMPLES,1,[Use Integer as Sample type])
-        PKG_CHECK_MODULES(SOUNDTOUCH, soundtouchi-1.4 >= 1.3.1, HAVE_SOUNDTOUCH=yes, HAVE_SOUNDTOUCH=no)
-        PKG_CHECK_MODULES(SOUNDTOUCH, soundtouchi-1.0 >= 1.3.1, HAVE_SOUNDTOUCH=yes, HAVE_SOUNDTOUCH=no)
-        if (test "x$HAVE_SOUNDTOUCH" = "xno") then
-           AC_MSG_ERROR([**libsoundtouchi >= 1.3.1 is needed to build libkolibre-narrator **])
-        fi
+        PKG_CHECK_MODULES(SOUNDTOUCH, soundtouch >= 1.7.0)
 else
         echo "****** Float sample type enabled ******"
         AC_DEFINE(FLOAT_SAMPLES,1,[Use Float as Sample type])
-        PKG_CHECK_MODULES(SOUNDTOUCH, soundtouch, HAVE_SOUNDTOUCH=yes, HAVE_SOUNDTOUCH=no)
-        PKG_CHECK_MODULES(SOUNDTOUCH, soundtouch-1.0, HAVE_SOUNDTOUCH=yes, HAVE_SOUNDTOUCH=no)
-        if (test "x$HAVE_SOUNDTOUCH" = "xno") then
-           AC_MSG_ERROR([**libsoundtouch >= 1.3.1 is needed to build libkolibre-narrator **])
-        fi
+        PKG_CHECK_MODULES(SOUNDTOUCH, soundtouch >= 1.7.0)
 fi
 
 AC_SUBST(SOUNDTOUCH_LIBS)
Index: git/src/Narrator.cpp
===================================================================
--- git.orig/src/Narrator.cpp
+++ git/src/Narrator.cpp
@@ -1011,7 +1011,7 @@ boost::signals2::connection Narrator::co
 /**
  * Called from the narrator_thread to copy audio data from the filter to portaudio.
  */
-void writeSamplesToPortaudio( Narrator* n, PortAudio& portaudio, Filter& filter, float* buffer )
+void writeSamplesToPortaudio( Narrator* n, PortAudio& portaudio, Filter& filter, short* buffer )
 {
     int outSamples = 0;
     Narrator::threadState state = n->getState();
@@ -1207,8 +1207,8 @@ void *narrator_thread(void *narrator)
 
 
                     int inSamples = 0;
-                    float *buffer = NULL;
-                    buffer = (float*)malloc(sizeof(float) * 2 * BUFFERSIZE);
+                    soundtouch::SAMPLETYPE *buffer = NULL;
+                    buffer = (soundtouch::SAMPLETYPE*)malloc(sizeof(soundtouch::SAMPLETYPE) * 2 * BUFFERSIZE);
 
                     do {
                         // change gain, tempo and pitch
Index: git/src/Narrator.h
===================================================================
--- git.orig/src/Narrator.h
+++ git/src/Narrator.h
@@ -119,7 +119,7 @@ class Narrator
         bool setupThread();
         /*! \cond PRIVATE */
         friend void adjustGainTempoPitch( Narrator* n, Filter& filter, float& gain, float& tempo, float& pitch );
-        friend void writeSamplesToPortaudio( Narrator* n, PortAudio& portaudio, Filter& filter, float* buffer );
+        friend void writeSamplesToPortaudio( Narrator* n, PortAudio& portaudio, Filter& filter, short* buffer );
         friend void *narrator_thread(void *narrator);
         /*! \endcond */
         pthread_mutex_t *narratorMutex;
Index: git/src/Filter.cpp
===================================================================
--- git.orig/src/Filter.cpp
+++ git/src/Filter.cpp
@@ -58,20 +58,20 @@ bool Filter::open(long rate, int channel
     return true;
 }
 
-bool Filter::write(float *buffer, unsigned int samples)
+bool Filter::write(short *buffer, unsigned int samples)
 {
     putSamples(buffer, samples); // One sample contains data from all channels
     return true;
 }
 
-unsigned int Filter::read(float *buffer, unsigned int bytes)
+unsigned int Filter::read(short *buffer, unsigned int bytes)
 {
     bytes = receiveSamples(buffer, bytes);
     applyGain(buffer, bytes);
     return bytes;
 }
 
-void Filter::applyGain(float *buffer, unsigned int samples)
+void Filter::applyGain(short *buffer, unsigned int samples)
 {
     // Change the gain on the buffer
     static unsigned int i;
@@ -83,7 +83,7 @@ void Filter::applyGain(float *buffer, un
     }
 }
 
-void Filter::fadeout(float *buffer, unsigned int bytes)
+void Filter::fadeout(short *buffer, unsigned int bytes)
 {
     // Linear fadeout on the samples in the buffer
     static unsigned int i;
Index: git/src/Filter.h
===================================================================
--- git.orig/src/Filter.h
+++ git/src/Filter.h
@@ -34,13 +34,13 @@ class Filter : public soundtouch::SoundT
         ~Filter();
 
         bool open(long rate, int channels);
-        bool write(float *buffer, unsigned int bytes);
-        unsigned int read(float *buffer, unsigned int bytes);
+        bool write(short *buffer, unsigned int bytes);
+        unsigned int read(short *buffer, unsigned int bytes);
         unsigned int availableSamples();
 
         void setGain(double gain) { mGain = gain; };
 
-        void fadeout(float *buffer, unsigned int bytes);
+        void fadeout(short *buffer, unsigned int bytes);
 
     private:
         double mTempo;
@@ -50,7 +50,7 @@ class Filter : public soundtouch::SoundT
         long mRate;
         int mChannels;
 
-        void applyGain(float *buffer, unsigned int samples);
+        void applyGain(short *buffer, unsigned int samples);
 };
 
 #endif
Index: git/src/PortAudio.cpp
===================================================================
--- git.orig/src/PortAudio.cpp
+++ git/src/PortAudio.cpp
@@ -86,7 +86,7 @@ bool PortAudio::open(long rate, int chan

         mOutputParameters.device = default_device; /* default output device */
         mOutputParameters.channelCount = channels;
-        mOutputParameters.sampleFormat = paFloat32;
+        mOutputParameters.sampleFormat = paInt16;
         mOutputParameters.suggestedLatency = 0; //Pa_GetDeviceInfo( mOutputParameters.device )->defaultLowOutputLatency;
         mOutputParameters.hostApiSpecificStreamInfo = NULL;

@@ -227,7 +227,7 @@ unsigned int PortAudio::getWriteAvailabl
     return writeAvailable;
 }
 
-bool PortAudio::write(float *buffer, unsigned int samples)
+bool PortAudio::write(short *buffer, unsigned int samples)
 {
     size_t elemWritten = ringbuf.writeElements(buffer, samples*mChannels);
 
@@ -280,12 +280,12 @@ int pa_stream_callback(
     long rate = ((PortAudio*)userData)->mRate;
     size_t elementsToRead = min( frameCount * channels, availableElements);
 
-    float* outbuf = (float*)output;
+    short* outbuf = (short*)output;
 
     size_t elementsRead = ringbuf->readElements(outbuf, elementsToRead);
 
     if( elementsRead < frameCount*channels ) {
-        memset( (outbuf+(elementsRead*channels)), 0, (frameCount*channels-elementsRead)*sizeof(float) );
+        memset( (outbuf+(elementsRead*channels)), 0, (frameCount*channels-elementsRead)*sizeof(short) );
         underrunms += (long) (frameCount * 1000.0) / rate;
         //std::cout << __FUNCTION__ << " Less read than requested, underrun ms:" << underrunms << std::endl;
     } else {
Index: git/src/PortAudio.h
===================================================================
--- git.orig/src/PortAudio.h
+++ git/src/PortAudio.h
@@ -41,7 +41,7 @@ class PortAudio {
         long getRemainingms();
 
         // Writes no more than getWriteAvailable samples
-        bool write(float *buffer, unsigned int samples);
+        bool write(short *buffer, unsigned int samples);
 
     private:
         bool isInitialized;
Index: git/src/OggStream.cpp
===================================================================
--- git.orig/src/OggStream.cpp
+++ git/src/OggStream.cpp
@@ -150,11 +150,14 @@ bool OggStream::open(string path)
 }
 
 // Returns samples (1 sample contains data from all channels)
-long OggStream::read(float* buffer, int bytes)
+long OggStream::read(short* buffer, int bytes)
 {
-    float **pcm;
-    long samples_read = ov_read_float(&mStream, &pcm, bytes, &mSection);
-    switch(samples_read) {
+    long bytes_read = ov_read(&mStream, (char*)buffer, bytes,
+            0, //0 for little endian, 1 for big endian
+            2, // 1 for 8-bit samples, 2 for 16-bit samples
+            1, //0 for unsigned, 1 for signed
+            &mSection);
+    switch(bytes_read) {
         case OV_HOLE:
             LOG4CXX_WARN(narratorOsLog, "Interruption in data while playing " << mStreamInfo);
             break;
@@ -162,12 +165,7 @@ long OggStream::read(float* buffer, int
             LOG4CXX_WARN(narratorOsLog, "Invalid stream section was supplied while playing " << mStreamInfo);
             break;
     }
-    //Convert the samples to a linear vector
-    float *bufptr = buffer;
-    for (long i = 0; i < samples_read; i++)
-        for(int c = 0; c < mChannels; c++)
-            *bufptr++ = pcm[c][i];
-    return (samples_read)/mChannels;
+    return (bytes_read/(sizeof(short)))/mChannels;
 }
 
 bool OggStream::close()
Index: git/src/OggStream.h
===================================================================
--- git.orig/src/OggStream.h
+++ git/src/OggStream.h
@@ -32,7 +32,7 @@ class OggStream
 
         bool open(const MessageAudio &);
         bool open(string);
-        long read(float* buffer, int bytes);
+        long read(short* buffer, int bytes);
         bool close();
 
         long getRate() { return mRate; };
Index: git/src/RingBuffer.cpp
===================================================================
--- git.orig/src/RingBuffer.cpp
+++ git/src/RingBuffer.cpp
@@ -66,12 +66,12 @@ const size_t RingBuffer::initialize(cons
     readIndex = 0;
     maxIndex = 0;
 
-    buffer = new float[elements];
+    buffer = new short[elements];
 
     if(buffer == NULL) return 0;
     maxIndex = elements;

-    memset(buffer, 0, elements * sizeof(float));
+    memset(buffer, 0, elements * sizeof(short));

     return elements;
 }
@@ -121,7 +121,7 @@ void RingBuffer::_advanceWriteIndex(cons
     //std::cout << __FUNCTION__ << " readIndex " << readIndex << " writeIndex " << writeIndex << " elements " << elements << //std::endl;
 }
 
-const size_t RingBuffer::writeElements(const float * source, size_t elements)
+const size_t RingBuffer::writeElements(const short * source, size_t elements)
 {
     //std::cout << __FUNCTION__ << " readIndex " << readIndex << " writeIndex " << writeIndex << //std::endl;
     pthread_mutex_lock(&bufMutex);
@@ -134,7 +134,7 @@ const size_t RingBuffer::writeElements(c
     // If write is contiguous all data can be copied at once
     if(wIndex + elements <= maxIndex) {
         //std::cout << __FUNCTION__ << " writing " << elements << " continuously at pos " << writeIndex << //std::endl;
-        memcpy(buffer + wIndex, source, elements * sizeof(float));
+        memcpy(buffer + wIndex, source, elements * sizeof(short));

     } // ..if not we need two separate writes
     else {
@@ -143,11 +143,11 @@ const size_t RingBuffer::writeElements(c

         // Write right part of buffer
         //std::cout << __FUNCTION__ << " writing right part of size " << rightSize << " elements at pos " << writeIndex << //std::endl;
-        memcpy(buffer + wIndex, source, rightSize * sizeof(float));
+        memcpy(buffer + wIndex, source, rightSize * sizeof(short));

         // Write the rest to left part of buffer
         //std::cout << __FUNCTION__ << " writing left part of size " << leftSize << " elements at pos 0" << //std::endl;
-        memcpy(buffer, source + rightSize, leftSize * sizeof(float));
+        memcpy(buffer, source + rightSize, leftSize * sizeof(short));
     }

     pthread_mutex_lock(&bufMutex);
@@ -167,7 +167,7 @@ void RingBuffer::_advanceReadIndex(const
     //std::cout << __FUNCTION__ << " readIndex " << readIndex << " writeIndex " << writeIndex << " elements " << elements << //std::endl;
 }
 
-const size_t RingBuffer::readElements(float *data, size_t elements)
+const size_t RingBuffer::readElements(short *data, size_t elements)
 {
     //std::cout << __FUNCTION__ << " readIndex " << readIndex << " writeIndex " << writeIndex << //std::endl;
     pthread_mutex_lock(&bufMutex);
@@ -180,7 +180,7 @@ const size_t RingBuffer::readElements(fl
     // If read is contiguous all data can be copied at once
     if(rIndex + elements <= maxIndex) {
         //std::cout << __FUNCTION__ << " reading " << elements << " continuously at pos " << readIndex << //std::endl;
-        memcpy(data, buffer + rIndex, elements * sizeof(float));
+        memcpy(data, buffer + rIndex, elements * sizeof(short));

     } // ..if not we need two separate reads
     else {
@@ -189,11 +189,11 @@ const size_t RingBuffer::readElements(fl

         // Read the right part of the buffer
         //std::cout << __FUNCTION__ << " reading right part of size " << rightSize << " elements from pos " << readIndex << //std::endl;
-        memcpy(data, buffer + rIndex, rightSize * sizeof(float));
+        memcpy(data, buffer + rIndex, rightSize * sizeof(short));

         // Read the rest from the left part the buffer
         //std::cout << __FUNCTION__ << " reading left part of size " << leftSize << " elements from pos 0" << //std::endl;
-        memcpy(data + rightSize, buffer, leftSize * sizeof(float));
+        memcpy(data + rightSize, buffer, leftSize * sizeof(short));
     }

     pthread_mutex_lock(&bufMutex);
Index: git/src/RingBuffer.h
===================================================================
--- git.orig/src/RingBuffer.h
+++ git/src/RingBuffer.h
@@ -38,10 +38,10 @@ class RingBuffer {
         const size_t getWriteAvailable();
 
         // Writes specified number of elements into ringbuffer from source, returns number of elements actually written
-        const size_t writeElements(const float * data, size_t elements);
+        const size_t writeElements(const short * data, size_t elements);
 
         // Reads specified number of elements from ringbuffer into target, returns number of elements actually read
-        const size_t readElements(float *data, size_t elements);
+        const size_t readElements(short *data, size_t elements);
 
         // Flushes all data in ringbuffer
         void flush();
@@ -53,7 +53,7 @@ class RingBuffer {
         void _advanceReadIndex(const size_t elements);
         void _advanceWriteIndex(const size_t elements);
 
-        float *buffer;
+        short *buffer;
         pthread_mutex_t bufMutex;
 
         size_t maxIndex;
