Index: git/src/Narrator.cpp
===================================================================
--- git.orig/src/Narrator.cpp
+++ git/src/Narrator.cpp
@@ -36,6 +36,7 @@ along with kolibre-narrator. If not, see
 #include <cstdlib>
 #include <sstream>
 #include <fstream>
+#include <sys/time.h>
 
 using namespace std;
 
@@ -62,6 +63,7 @@ using namespace std;
 log4cxx::LoggerPtr narratorLog(log4cxx::Logger::getLogger("kolibre.narrator.narrator"));
 
 Narrator * Narrator::pinstance = 0;
+long sleepTime = 5000;
 
 void *narrator_thread(void *narrator) ;
 
@@ -1028,9 +1030,15 @@ void writeSamplesToPortaudio( Narrator*
     // See if we have any finished samples
     // One filter sample contains data from all channels
     while((outSamples = filter.numSamples()) != 0 && state == Narrator::PLAY) {
-        int available = portaudio.getWriteAvailable();
-
-        //LOG4CXX_DEBUG(narratorLog, "Got writeavailable %d, outSamples: %d", available, outSamples);
+        int available;
+        struct timeval t0, t1;
+        gettimeofday(&t0, 0);
+        while( (available = portaudio.getWriteAvailable()) < BUFFERSIZE ){
+            usleep(sleepTime/2);
+        }
+        gettimeofday(&t1, 0);
+        sleepTime = (t1.tv_sec-t0.tv_sec)*1000000 + t1.tv_usec-t0.tv_usec;
+        LOG4CXX_TRACE(narratorLog, "Write available:" << available << ", sleep time is: " << sleepTime << ", got " << outSamples << " in buffer");
 
         if(available > outSamples) available = outSamples;
 
@@ -1143,7 +1151,7 @@ void *narrator_thread(void *narrator)
 
 
             int inSamples = 0;
-            soundtouch::SAMPLETYPE* buffer = new soundtouch::SAMPLETYPE[2*BUFFERSIZE];
+            soundtouch::SAMPLETYPE* buffer = new soundtouch::SAMPLETYPE[oggstream.getChannels()*BUFFERSIZE];
             //buffer = (short*)malloc(sizeof(short) * 2 * BUFFERSIZE);
             // long totalSamplesRead = 0;
             do {
@@ -1151,18 +1159,18 @@ void *narrator_thread(void *narrator)
                 adjustGainTempoPitch(n, filter, gain, tempo, pitch);
 
                 // read some stuff from the oggstream
-                inSamples = oggstream.read(buffer, BUFFERSIZE*2);
+                inSamples = oggstream.read(buffer, BUFFERSIZE*oggstream.getChannels());
 
                 //printf("Read %d samples from oggstream\n", inSamples);
 
                 if(inSamples != 0) {
                     filter.write(buffer, inSamples); // One sample contains data for all channels here
+                    writeSamplesToPortaudio( n, portaudio, filter, buffer );
                 } else {
                     LOG4CXX_INFO(narratorLog, "Flushing soundtouch buffer");
                     filter.flush();
                 }
 
-                writeSamplesToPortaudio( n, portaudio, filter, buffer );
                 state = n->getState();
 
             } while (inSamples != 0 && state == Narrator::PLAY && !n->bResetFlag);
@@ -1216,29 +1224,28 @@ void *narrator_thread(void *narrator)
 
 
                     int inSamples = 0;
-                    float *buffer = NULL;
-                    buffer = (float*)malloc(sizeof(float) * 2 * BUFFERSIZE);
+                    soundtouch::SAMPLETYPE* buffer = new soundtouch::SAMPLETYPE[oggstream.getChannels()*BUFFERSIZE];
 
                     do {
                         // change gain, tempo and pitch
                         adjustGainTempoPitch(n, filter, gain, tempo, pitch);
 
                         // read some stuff from the oggstream
-                        inSamples = oggstream.read(buffer, BUFFERSIZE);
+                        inSamples = oggstream.read(buffer, BUFFERSIZE*oggstream.getChannels());
 
                         if(inSamples != 0) {
                             filter.write(buffer, inSamples);
+                            writeSamplesToPortaudio( n, portaudio, filter, buffer );
                         } else {
                             LOG4CXX_INFO(narratorLog, "Flushing soundtouch buffer");
                             filter.flush();
                         }
 
-                        writeSamplesToPortaudio( n, portaudio, filter, buffer );
                         state = n->getState();
 
                     } while (inSamples != 0 && state == Narrator::PLAY && !n->bResetFlag);
 
-                    if(buffer != NULL) free(buffer);
+                    if(buffer != NULL) delete [] (buffer);
                     oggstream.close();
                     audio++;
 
@@ -1251,8 +1258,8 @@ void *narrator_thread(void *narrator)
         // Abort stream?
         if(n->bResetFlag) {
             n->bResetFlag = false;
+            portaudio.stop();
             filter.clear();
-            portaudio.abort();
         }
 
     } while(state != Narrator::EXIT);
Index: git/src/PortAudio.cpp
===================================================================
--- git.orig/src/PortAudio.cpp
+++ git/src/PortAudio.cpp
@@ -26,7 +26,7 @@ along with kolibre-narrator. If not, see
 #include <cstring>
 #include <log4cxx/logger.h>
 
-#define RINGBUFFERSIZE 1024*16
+#define RINGBUFFERSIZE 1024*32
 
 // create logger which will become a child to logger kolibre.narrator
 log4cxx::LoggerPtr narratorPaLog(log4cxx::Logger::getLogger("kolibre.narrator.portaudio"));
@@ -95,15 +95,14 @@ bool PortAudio::open(long rate, int chan
 
         LOG4CXX_DEBUG(narratorPaLog, "Opening device: " << devinfo->name << " (" << hostapiinfo->name << "), channels: " << channels << ", rate: " << rate <<" (" << devinfo->defaultSampleRate << ")");
 
-        unsigned long framesPerBuffer = 1024;
+        unsigned long framesPerBuffer = 440;
 
 #ifdef WIN32
         framesPerBuffer = 4096;
 #endif
 
-        mError = Pa_OpenStream(&pStream, NULL, &mOutputParameters, rate, framesPerBuffer,
+        mError = Pa_OpenStream(&pStream, NULL, &mOutputParameters, rate, framesPerBuffer,
                 paNoFlag, pa_stream_callback, this);
-
         if(mError != paNoError) {
             LOG4CXX_ERROR(narratorPaLog, "Failed to open stream: " << Pa_GetErrorText(mError));
             return false;
@@ -196,11 +195,11 @@ unsigned int PortAudio::getWriteAvailabl
         writeAvailable = ringbuf.getWriteAvailable();
 
         if( writeAvailable == 0 ) {
-            usleep(200000); //200 ms
-            //LOG4CXX_DEBUG(narratorPaLog, "getWriteAvailable = 0, Pa_IsStreamActive = " << Pa_IsStreamActive(pStream));
+            usleep(20000); //20 ms
+            LOG4CXX_TRACE(narratorPaLog, "getWriteAvailable = 0, Pa_IsStreamActive = " << Pa_IsStreamActive(pStream));
         }
 
-        if(waitCount++ > 10) {
+        if(waitCount++ > 40) {
             LOG4CXX_ERROR(narratorPaLog, "getWriteAvailable waittime exceeded, restarting stream");
 
             mError = Pa_AbortStream(pStream);
@@ -232,8 +231,8 @@ bool PortAudio::write(float *buffer, uns
     size_t elemWritten = ringbuf.writeElements(buffer, samples*mChannels);
 
     // Try starting the stream
-    if(!isStarted) {
-        //LOG4CXX_INFO(narratorPaLog, "Starting stream");
+    if(!isStarted && ringbuf.getWriteAvailable() <= (RINGBUFFERSIZE/2)) {
+        LOG4CXX_TRACE(narratorPaLog, "Starting stream");
         mError = Pa_StartStream(pStream);
         if(mError != paNoError) {
             LOG4CXX_ERROR(narratorPaLog, "Failed to start stream: " << Pa_GetErrorText(mError));
@@ -241,6 +240,8 @@ bool PortAudio::write(float *buffer, uns
         mLatency = (long) (Pa_GetStreamInfo(pStream)->outputLatency * 1000.0);
         isStarted = true;
     }
+    else if(!isStarted )
+        LOG4CXX_TRACE(narratorPaLog, "Buffering: " << ((RINGBUFFERSIZE - ringbuf.getWriteAvailable()) * 100) / (RINGBUFFERSIZE) << "%");
 
     if( elemWritten < samples)
         return false;
@@ -270,6 +271,13 @@ int pa_stream_callback(
     (void) timeInfo;    /* Prevent unused variable warning. */
     (void) input; /* Prevent unused variable warning. */
 
+    //if(statusFlags & paOutputUnderflow)
+    //    LOG4CXX_WARN(narratorPaLog, "Output underflow!");
+    //if(statusFlags & paOutputOverflow)
+    //    LOG4CXX_WARN(narratorPaLog, "Output overflow!");
+    //if(statusFlags & paPrimingOutput)
+    //    LOG4CXX_WARN(narratorPaLog, "Priming output!");
+
     static long underrunms = 0;
 
     RingBuffer *ringbuf = &((PortAudio*)userData)->ringbuf;
@@ -287,9 +295,9 @@ int pa_stream_callback(
     if( elementsRead < frameCount*channels ) {
         memset( (outbuf+(elementsRead*channels)), 0, (frameCount*channels-elementsRead)*sizeof(float) );
         underrunms += (long) (frameCount * 1000.0) / rate;
-        //std::cout << __FUNCTION__ << " Less read than requested, underrun ms:" << underrunms << std::endl;
+        LOG4CXX_DEBUG(narratorPaLog, " Less read than requested, underrun ms:" << underrunms );
     } else {
-        //std::cout << __FUNCTION__ << " availableElements: " << availableElements << " elementsToRead: " << elementsToRead << " elementsRead:" << elementsRead << std::endl;
+        //LOG4CXX_TRACE(narratorPaLog, " availableElements: " << availableElements << " elementsToRead: " << elementsToRead << " elementsRead:" << elementsRead);
         underrunms = 0;
     }
 
